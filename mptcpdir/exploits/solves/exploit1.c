#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <sched.h>
#include <arpa/inet.h>

#define MPTCP_ENABLED           42
#define MPTCP_SCHEDULER         43
#define MPTCP_PATH_MANAGER      44
#define MPTCP_INFO              45

#define PORT 9070

struct mptcp_info {
	int   tcp_info_len;   /* Length of each struct tcp_info in subflows pointer */
	int   sub_len;        /* Total length of memory pointed to by subflows pointer */
	int   meta_len;       /* Length of memory pointed to by meta_info */
	int   sub_info_len;   /* Length of each struct mptcp_sub_info in subflow_info pointer */
	int   total_sub_info_len;     /* Total length of memory pointed to by subflow_info */

	void  *meta_info;
	void  *initial;
	void  *subflows;      /* Pointer to array of tcp_info structs */
	void  *subflow_info;
};


int main(void){
        struct sockaddr_in saddr, caddr, oaddr, unspec;
	struct mptcp_info mptcp_info;
	int fd_c,fd_s,fd_o;
	int enabled;
	int size;
	int i;
	struct tcp_md5sig md5;
	char *key = "PASSWORD_SECRET";

	memset(&oaddr,'\0',sizeof(oaddr));
	memset(&saddr,'\0',sizeof(saddr));
	memset(&caddr,'\0',sizeof(caddr));
	memset(&unspec,'\0',sizeof(unspec));
	memset(&mptcp_info,'\0',sizeof(mptcp_info));

	fd_s = socket(AF_INET,SOCK_STREAM,0);// create server tcp-ip socket
	if(fd_s < 0){
		return 0;
	}

	fd_c = socket(AF_INET,SOCK_STREAM,0);//create client tcp-ip socket
	if(fd_c < 0){
		return 0;
	}

	enabled = 1;

	if(setsockopt(fd_s,SOL_TCP,MPTCP_ENABLED,&enabled,4) < 0){//enabled MPTCP on fd_s
		perror("setsockopt");
		exit(EXIT_FAILURE);
	}

	char pathmanager[] = "ndiffports";
	if(setsockopt(fd_s, SOL_TCP, MPTCP_PATH_MANAGER, pathmanager, sizeof(pathmanager)) < 0){//create different subflows across same pair
		perror("pathmanager setsockopt");						//of IP addresses by modifying source port.
		exit(EXIT_FAILURE);
	}

	char scheduler[] = "redundant";
	if(setsockopt(fd_s, SOL_TCP, MPTCP_SCHEDULER, scheduler, sizeof(scheduler)) < 0){//This scheduler will try to transmit the traffic on all 
//available subflows in a redundant way. It is useful when one wants to achieve the lowest possible latency by sacrificing the bandwidth.
		perror("scheduler setsockopt");
		exit(EXIT_FAILURE);
	}


	if(setsockopt(fd_c,SOL_TCP,MPTCP_ENABLED,&enabled,4) < 0){//enable MPTCP on fd_c
		perror("setsockopt");
		exit(EXIT_FAILURE);
	}

	md5.tcpm_addr = *(struct sockaddr_storage *) &saddr;
        strcpy(&md5.tcpm_key, key);
        md5.tcpm_keylen = strlen(key);

	saddr.sin_family = AF_INET;
      	saddr.sin_port = htons(PORT);

	if(bind(fd_s,(struct sockaddr *)&saddr,sizeof(saddr)) < 0){//bind server socket
		perror("bind");
		exit(EXIT_FAILURE);
	}

	if(listen(fd_s,1000) < 0){//start server
		perror("listen");
		exit(EXIT_FAILURE);
	}

	caddr.sin_family = AF_INET;
	caddr.sin_port = htons(PORT);
	caddr.sin_addr.s_addr = inet_addr("127.0.0.1"); 

	if(connect(fd_c,(struct sockaddr *)&caddr,sizeof(caddr)) < 0){//connect client
		perror("connect");
		exit(EXIT_FAILURE);
	}

	unspec.sin_family = AF_UNSPEC;

	connect(fd_c,(struct sockaddr *)&unspec,sizeof(unspec));

	md5.tcpm_addr = *(struct sockaddr_storage *) &saddr;
        strcpy(&md5.tcpm_key, key);
        md5.tcpm_keylen = strlen(key);

	if(setsockopt(fd_c,IPPROTO_TCP,TCP_MD5SIG,&md5,sizeof(md5))){//enable md5sig
		perror("setsockopt");
		exit(EXIT_FAILURE);
	}

	if(connect(fd_c,(struct sockaddr *)&caddr,sizeof(caddr)) < 0){
		perror("connect");
		exit(EXIT_FAILURE);
	}

	char *msg = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";	
	if(write(fd_c,msg,strlen(msg)) < 0){
		perror("write");
		exit(EXIT_FAILURE);
	}

	int olen = sizeof(oaddr);
	if((fd_o = accept(fd_s,(struct sockaddr *)&oaddr,&olen)) < 0){
		perror("accept");
		exit(EXIT_FAILURE);
	}

	char buffer[256];

	memset(&buffer,'\0',sizeof(buffer));
	
	if(read(fd_o,&buffer,sizeof(buffer) - 1) < 0){
		perror("read");
		exit(EXIT_FAILURE);
	}

	printf("Result: %s\n",buffer);

	close(fd_o);
	close(fd_c);
	close(fd_s);
	
return 0;
}
